SECTION .data
int_message db 'Input: Enter an integer value:',0
int_input_format db '%hd', 0 ; for short as integer is of 2 bytes in erplag
int_output_format_same_line db '%hd ', 0
new_line_character_string db  10, 0
int_output_format db 'You entered: %hd', 10, 0
array_index_out_of_bounds_message db 'RUN TIME ERROR: Array Index Out of Bound', 10, 0
simple_int_output_format db '%hd', 10, 0
simple_bool_output_format db '%s', 0
simple_string_output_format db '%s', 0
simple_real_output_format db '%f', 10, 0
bool_message db 'Input: Enter a boolean value, where 0 is treated as false and anything else as true:',0
bool_input_format db '%hhd', 0 ; for boolean
bool_output_format db 'You entered: %hhd', 10, 0
bool_true db 'true',10, 0
bool_false db 'false',10, 0
array_message resb 64 ; not a constant
global  _main
extern _puts
extern _scanf
extern _printf
extern _malloc
SECTION .text
_main:
	call DRIVER
	exit:
	mov rax, 0x02000001         ; system call for exit; CHANGE IN LINUX
	xor rdi, rdi; exit code 0
	syscall ;invoke OS to exit

	exit_array_error:
	;align stack
	mov rbx, rsp
	and rsp, -16
	lea rdi, [rel simple_string_output_format]
	lea rsi, [rel array_index_out_of_bounds_message]
	call _printf
	;restore stack
	mov rsp, rbx
	mov rax, 0x02000001         ; system call for exit; CHANGE IN LINUX
	xor rdi, rdi; exit code 0
	syscall ;invoke OS to exit

;first argument in rax
_print_message:
	push rdi 
	lea  rdi, [rax]    ; First argument is address of message
	call      _puts                   ; puts(message)
	pop rdi
	ret
;1st argument: integer to print in rax
;printf("%d", i); 
_print_integer_id:
	mov r12, rsp; 

	and rsp, -16
	lea rdi, [rel simple_int_output_format]; printf first arg %hd
	mov rsi, rax ; printf second arg 
	call _printf

	;epilog
	mov rsp, r12
	ret
; assumes the boolean value is in rax ; 0 = false, anything else true
_print_boolean_id:
	test rax, rax
	jz printFalse
	lea rdi, [rel simple_bool_output_format]
	lea rsi, [rel bool_true]
	call _printf
	ret
	printFalse: 
		lea rdi, [rel simple_bool_output_format]
		lea rsi, [rel bool_false]
		call _printf
		ret
DRIVER:
	;allocate space for module
	push rbp
	mov rbp, rsp
	sub rsp, 2
	;node integer literal, store it in temporary
	sub rsp, 2
	mov r8, 1
	mov word[rbp - 4], r8w
	mov word[rbp - 2], 1
	; while statement node
	mov rcx, rsp; store initial value of rsp
	label0:
	; while predicate statements begin
	; allocate space for while
	sub rsp, 0
	;node integer literal, store it in temporary
	sub rsp, 2
	mov r8, 5
	mov word[rbp - 4], r8w
	movsx r8, word[rbp - 2] ; load left for plus
	mov r9, 5
	sub rsp, 1; allocate space for temporary boolean t2
	cmp r8,r9 ; r8 = a; r9 = b
	jle label2
	mov byte[rbp - 5], 0; move result into temporary ; a <= b
	jmp label3
	label2: ; a > b
	mov byte[rbp - 5], 1; move result into temporary
	label3:
	; while predicate statements end
	; extract result of temporary generated by while's binary predicate
	movsx r11, byte[rbp - 5]
	test r11, r11
	jz label1
	; while's statements begin
	;node integer literal, store it in temporary
	sub rsp, 2
	mov r8, 1
	mov word[rbp - 7], r8w
	movsx r8, word[rbp - 2] ; load left for plus
	mov r9, 1
	add r9, r8
	sub rsp, 2
	mov word[rbp - 9], r9w
	movsx r8, word[rbp - 9]
	mov word[rbp - 2], r8w
	; push caller saved registers
	push rbp
	push r10
	push r11
	push rdi
	push rsi
	push rdx
	push rcx
	push r8
	push r9
	mov rbx, rsp
	and rsp, -16
	movsx rax, word[rbp - 2]
	call _print_integer_id
	mov rsp, rbx
	; pop caller saved registers
	pop r9
	pop r8
	pop rcx
	pop rdx
	pop rsi
	pop rdi
	pop r11
	pop r10
	pop rbp
	jmp label0
	; while's statements end
	label1:
	; deallocate space from while
	mov rsp, rcx
	; push caller saved registers
	push rbp
	push r10
	push r11
	push rdi
	push rsi
	push rdx
	push rcx
	push r8
	push r9
;print boolean
;print boolean
mov rbx, rsp ; preserve rsp
and rsp, -16
; printf("%s", i); 
lea rdi, [rel simple_bool_output_format] ; Use new format string
lea rsi, [rel bool_false]
call _printf 
mov rsp, rbx ; restore rsp
	; pop caller saved registers
	pop r9
	pop r8
	pop rcx
	pop rdx
	pop rsi
	pop rdi
	pop r11
	pop r10
	pop rbp
	;place return values in desired registers
	;deallocate space from module
	add rsp, 4
	pop rbp
	ret
